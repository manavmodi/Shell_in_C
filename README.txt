ASSIGNMENT 2 COP290: Writing A Basic Shell
This  assignment is modeled on the basic functions of a shell which is similar to what is commonly known as a 'terminal' in Linux. It is programmed in C and can be launched by running the makefie (running the 'make' command in your linux terminal) in the directory in which the program exists. The functions which it supports are as follows:

COMMANDS:
I. pwd : Displays the directory in it it will perform the operations.
II. cd "dir" : changes the directory in which it will perform the operations to dir. But it won't change the directory of the main terminal.
III. mkdir "dir" : makes a new directory named dir in the directory displayed by 'pwd' or if address is provided in "dir" then it will make the new directory at that address.
IV. rmdir "dir" : removes the directory named dir in the directory displayed by 'pwd' or if address is provided in "dir" then it will remove the directory from that address.
V. exit : exits our so-called terminal.
VI. ./a.out : executes the program a.out if it is present in our current directory.
VII. ./a.out < infile > outfile : executes the program a.out using infile as an input file and outfile as an output file provided all 3 of them exist in our current directory. However it is order 					specific so if postions of any of './a.out', '<' or '>' are chenged then it won't work. This is called 'Input-Output Redirection'
VII. ./a.out < infile : executes the program a.out using infile as an input. It is order specefic too.
IX. ./a.out > outfile : executes the program a.out using outfile as an output file. It is order specefic too.
X. ./a.out | ./b.out | ./c.out : executes the program a.out and uses its output as an input for b.out then it executes b.out and its output is used as input for c.out and finally executes c.out and 					displays its output. This is called 'Piplining'. It works for 2 or more no. of programs. However since the input string's no. of words are limited to 20 so max 10 					programs can be piped together.
XI. ./a.out < in.txt | ./b.out | ./c.out > out.txt : This works the same as the upper command except that the input is taken from in.txt and the output is redirected to out.txt. It works for 2 or more 								programs.

DESCRIPTION:
1). The code is the in the assignment2.c file and its compiled and run in the makefile.
2.) The main functionalties in this code are all handled in the main() function itself. It has an infinite while loop which breaks only if input string is "exit". In the while loop firstly parsing is handled. For that an array of strings called args is initialised to null first and then the strtok function is used which uses " /n" as a delimiter to tokenize the input string. Thus using strtok repitvely we parse the words of the input string into an array of strings.
3.) Now the code contains 4 if-else conditions. That divides the code into 3 main sections on the basis of no. of words in the input string i.e. 1 word, 2 words or more than 3 words.
4.) In the 1 word case, we have 3 functions namely : pwd, exit and execution of a single isolated program. The pwd is handled using getcwd() function and the break command is used for exit. For the execution of a file, we fork the process into 2 processes. The child processs executes the program using execvp() and the parent process waits for the child process to finish using the wait() command.
5.) In the 2 word case, we have 3 functions : cd, mkdir and rmdir. The cd is handled using chdir() function and the mkdir and rmdir are handled using mkdir() and rmdir() functions. 
6.) In the 3 word case, we first count the no. of "|" that we have to determine the size of the pipe array later. We also have a bin and bout integer that change to 2  from 0 if a "<" or a ">" is found respectively. Then we check for piping. For piping, we initialize an array of integers known as pipes whose size is twice the no. of "|" symbols. Then we pipe this array using the pipe command which turns the array into an array of file descriptors referring to the ends of the pipe. Then we call the multipiping function described later. After that we close all the pipes so that they no longer refer to any file and may be reused and then we wait for the child processes in the multipiping function to finish in order.
7.) For input-output redirection we use 2 integers named in and out. using the open() function we can assign to these integers the file descriptors of the input and output files. Then we makes a copy of this integers in and out using the dup2() function. Then both the original file descriptors are closed using the close() function so that they no longer refer to any file and may be reused and finally we execute the program using the execvp() function. All this is done in a seperate child process while the parent process waits for it to complete.
8.) MULTIPIPING() : In this fuction if the size of the pipes array is 2 then it is handled seperately for convinience purposes. But its essence is the same as the other case. So in the other case (size > 			    2) there is for loop in which we repitively fork() the process into two. The child process then creates a copy of the read file descriptor of the preceding program and the write file 			    descriptor of the succeeding program if there is one. It also checks if there is any input file for the first program using the bin value and redirects its input file to it the  same 			    way as in point '7.)'. It does the same after checking if there is any output file for the final program. Then it closes all the pipes and executes the program using the execvp() 			    function.  
